"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Availability`."""
  availabilities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailabilityFilter
  ): AvailabilitiesConnection

  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter
  ): BookingsConnection

  """Reads and enables pagination through a set of `CustomAvailability`."""
  customAvailabilities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CustomAvailability`."""
    orderBy: [CustomAvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomAvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CustomAvailabilityFilter
  ): CustomAvailabilitiesConnection

  """Reads and enables pagination through a set of `Event`."""
  events(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EventCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EventFilter
  ): EventsConnection

  """Reads and enables pagination through a set of `Team`."""
  teams(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TeamFilter
  ): TeamsConnection

  """Reads and enables pagination through a set of `TeamMembership`."""
  teamMemberships(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamMembership`."""
    orderBy: [TeamMembershipsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamMembershipCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TeamMembershipFilter
  ): TeamMembershipsConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection

  """Reads and enables pagination through a set of `UserDevice`."""
  userDevices(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDeviceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDeviceFilter
  ): UserDevicesConnection
  availability(id: String!): Availability
  booking(eventId: String!, userId: String!): Booking
  customAvailability(id: String!): CustomAvailability
  event(id: String!): Event
  team(id: String!): Team
  teamMembership(id: String!): TeamMembership
  user(oidcId: String!): User
  userDevice(userId: String!, token: String!): UserDevice
  userDeviceByToken(token: String!): UserDevice

  """Reads a single `Availability` using its globally unique `ID`."""
  availabilityByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Availability`.
    """
    nodeId: ID!
  ): Availability

  """Reads a single `Booking` using its globally unique `ID`."""
  bookingByNodeId(
    """The globally unique `ID` to be used in selecting a single `Booking`."""
    nodeId: ID!
  ): Booking

  """Reads a single `CustomAvailability` using its globally unique `ID`."""
  customAvailabilityByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CustomAvailability`.
    """
    nodeId: ID!
  ): CustomAvailability

  """Reads a single `Event` using its globally unique `ID`."""
  eventByNodeId(
    """The globally unique `ID` to be used in selecting a single `Event`."""
    nodeId: ID!
  ): Event

  """Reads a single `Team` using its globally unique `ID`."""
  teamByNodeId(
    """The globally unique `ID` to be used in selecting a single `Team`."""
    nodeId: ID!
  ): Team

  """Reads a single `TeamMembership` using its globally unique `ID`."""
  teamMembershipByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TeamMembership`.
    """
    nodeId: ID!
  ): TeamMembership

  """Reads a single `User` using its globally unique `ID`."""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User

  """Reads a single `UserDevice` using its globally unique `ID`."""
  userDeviceByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserDevice`.
    """
    nodeId: ID!
  ): UserDevice
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Availability` values."""
type AvailabilitiesConnection {
  """A list of `Availability` objects."""
  nodes: [Availability!]!

  """
  A list of edges which contains the `Availability` and cursor to aid in pagination.
  """
  edges: [AvailabilitiesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Availability` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AvailabilityAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Availability` for these aggregates."""
    groupBy: [AvailabilityGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AvailabilityHavingInput
  ): [AvailabilityAggregates!]
}

type Availability implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  userId: String!
  dayOfWeek: Int!
  startTime: Datetime
  endTime: Datetime

  """Reads a single `User` that is related to this `Availability`."""
  user: User
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  oidcId: String!
  firstName: String
  lastName: String
  gender: UserGender
  birthDay: Datetime
  email: String
  tel: String
  picture: String

  """Reads and enables pagination through a set of `UserDevice`."""
  userDevicesByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDeviceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDeviceFilter
  ): UserDevicesConnection!

  """Reads and enables pagination through a set of `TeamMembership`."""
  teamMembershipsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamMembership`."""
    orderBy: [TeamMembershipsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamMembershipCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TeamMembershipFilter
  ): TeamMembershipsConnection!

  """Reads and enables pagination through a set of `Availability`."""
  availabilitiesByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailabilityFilter
  ): AvailabilitiesConnection!

  """Reads and enables pagination through a set of `CustomAvailability`."""
  customAvailabilitiesByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CustomAvailability`."""
    orderBy: [CustomAvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomAvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CustomAvailabilityFilter
  ): CustomAvailabilitiesConnection!

  """Reads and enables pagination through a set of `Event`."""
  eventsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EventCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EventFilter
  ): EventsConnection!

  """Reads and enables pagination through a set of `Booking`."""
  bookingsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter
  ): BookingsConnection!
}

enum UserGender {
  MALE
  FEMALE
}

"""A connection to a list of `UserDevice` values."""
type UserDevicesConnection {
  """A list of `UserDevice` objects."""
  nodes: [UserDevice!]!

  """
  A list of edges which contains the `UserDevice` and cursor to aid in pagination.
  """
  edges: [UserDevicesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserDevice` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserDeviceAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `UserDevice` for these aggregates."""
    groupBy: [UserDeviceGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserDeviceHavingInput
  ): [UserDeviceAggregates!]
}

type UserDevice implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: String!
  token: String!
  ua: JSON

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""A `UserDevice` edge in the connection."""
type UserDevicesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserDevice` at the end of the edge."""
  node: UserDevice!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type UserDeviceAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDeviceDistinctCountAggregates
}

type UserDeviceDistinctCountAggregates {
  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of token across the matching connection"""
  token: BigInt

  """Distinct count of ua across the matching connection"""
  ua: BigInt
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""Grouping methods for `UserDevice` for usage during aggregation."""
enum UserDeviceGroupBy {
  USER_ID
  UA
}

"""Conditions for `UserDevice` aggregates."""
input UserDeviceHavingInput {
  AND: [UserDeviceHavingInput!]
  OR: [UserDeviceHavingInput!]
}

"""Methods to use when ordering `UserDevice`."""
enum UserDevicesOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  TOKEN_ASC
  TOKEN_DESC
  UA_ASC
  UA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `UserDevice` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UserDeviceCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `token` field."""
  token: String

  """Checks for equality with the object’s `ua` field."""
  ua: JSON
}

"""
A filter to be used against `UserDevice` object types. All fields are combined with a logical ‘and.’
"""
input UserDeviceFilter {
  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `token` field."""
  token: StringFilter

  """Filter by the object’s `ua` field."""
  ua: JSONFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UserDeviceFilter!]

  """Checks for any expressions in this list."""
  or: [UserDeviceFilter!]

  """Negates the expression."""
  not: UserDeviceFilter
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against JSON fields. All fields are combined with a logical ‘and.’
"""
input JSONFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: JSON

  """Not equal to the specified value."""
  notEqualTo: JSON

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: JSON

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: JSON

  """Included in the specified list."""
  in: [JSON!]

  """Not included in the specified list."""
  notIn: [JSON!]

  """Less than the specified value."""
  lessThan: JSON

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: JSON

  """Greater than the specified value."""
  greaterThan: JSON

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: JSON

  """Contains the specified JSON."""
  contains: JSON

  """Contains the specified key."""
  containsKey: String

  """Contains all of the specified keys."""
  containsAllKeys: [String!]

  """Contains any of the specified keys."""
  containsAnyKeys: [String!]

  """Contained by the specified JSON."""
  containedBy: JSON
}

"""
A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
"""
input UserFilter {
  """Filter by the object’s `oidcId` field."""
  oidcId: StringFilter

  """Filter by the object’s `firstName` field."""
  firstName: StringFilter

  """Filter by the object’s `lastName` field."""
  lastName: StringFilter

  """Filter by the object’s `gender` field."""
  gender: UserGenderFilter

  """Filter by the object’s `birthDay` field."""
  birthDay: DatetimeFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Filter by the object’s `tel` field."""
  tel: StringFilter

  """Filter by the object’s `picture` field."""
  picture: StringFilter

  """Filter by the object’s `userDevicesByUserId` relation."""
  userDevicesByUserId: UserToManyUserDeviceFilter

  """Some related `userDevicesByUserId` exist."""
  userDevicesByUserIdExist: Boolean

  """Filter by the object’s `teamMembershipsByUserId` relation."""
  teamMembershipsByUserId: UserToManyTeamMembershipFilter

  """Some related `teamMembershipsByUserId` exist."""
  teamMembershipsByUserIdExist: Boolean

  """Filter by the object’s `availabilitiesByUserId` relation."""
  availabilitiesByUserId: UserToManyAvailabilityFilter

  """Some related `availabilitiesByUserId` exist."""
  availabilitiesByUserIdExist: Boolean

  """Filter by the object’s `customAvailabilitiesByUserId` relation."""
  customAvailabilitiesByUserId: UserToManyCustomAvailabilityFilter

  """Some related `customAvailabilitiesByUserId` exist."""
  customAvailabilitiesByUserIdExist: Boolean

  """Filter by the object’s `eventsByUserId` relation."""
  eventsByUserId: UserToManyEventFilter

  """Some related `eventsByUserId` exist."""
  eventsByUserIdExist: Boolean

  """Filter by the object’s `bookingsByUserId` relation."""
  bookingsByUserId: UserToManyBookingFilter

  """Some related `bookingsByUserId` exist."""
  bookingsByUserIdExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
A filter to be used against UserGender fields. All fields are combined with a logical ‘and.’
"""
input UserGenderFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UserGender

  """Not equal to the specified value."""
  notEqualTo: UserGender

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UserGender

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UserGender

  """Included in the specified list."""
  in: [UserGender!]

  """Not included in the specified list."""
  notIn: [UserGender!]

  """Less than the specified value."""
  lessThan: UserGender

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UserGender

  """Greater than the specified value."""
  greaterThan: UserGender

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UserGender
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against many `UserDevice` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyUserDeviceFilter {
  """
  Every related `UserDevice` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: UserDeviceFilter

  """
  Some related `UserDevice` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: UserDeviceFilter

  """
  No related `UserDevice` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: UserDeviceFilter

  """Aggregates across related `UserDevice` match the filter criteria."""
  aggregates: UserDeviceAggregatesFilter
}

"""A filter to be used against aggregates of `UserDevice` object types."""
input UserDeviceAggregatesFilter {
  """
  A filter that must pass for the relevant `UserDevice` object to be included within the aggregate.
  """
  filter: UserDeviceFilter

  """Distinct count aggregate over matching `UserDevice` objects."""
  distinctCount: UserDeviceDistinctCountAggregateFilter
}

input UserDeviceDistinctCountAggregateFilter {
  userId: BigIntFilter
  token: BigIntFilter
  ua: BigIntFilter
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A filter to be used against many `TeamMembership` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyTeamMembershipFilter {
  """
  Every related `TeamMembership` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TeamMembershipFilter

  """
  Some related `TeamMembership` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TeamMembershipFilter

  """
  No related `TeamMembership` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TeamMembershipFilter

  """Aggregates across related `TeamMembership` match the filter criteria."""
  aggregates: TeamMembershipAggregatesFilter
}

"""
A filter to be used against `TeamMembership` object types. All fields are combined with a logical ‘and.’
"""
input TeamMembershipFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `teamId` field."""
  teamId: StringFilter

  """Filter by the object’s `role` field."""
  role: TeamRoleFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `team` relation."""
  team: TeamFilter

  """Checks for all expressions in this list."""
  and: [TeamMembershipFilter!]

  """Checks for any expressions in this list."""
  or: [TeamMembershipFilter!]

  """Negates the expression."""
  not: TeamMembershipFilter
}

"""
A filter to be used against TeamRole fields. All fields are combined with a logical ‘and.’
"""
input TeamRoleFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: TeamRole

  """Not equal to the specified value."""
  notEqualTo: TeamRole

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: TeamRole

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: TeamRole

  """Included in the specified list."""
  in: [TeamRole!]

  """Not included in the specified list."""
  notIn: [TeamRole!]

  """Less than the specified value."""
  lessThan: TeamRole

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: TeamRole

  """Greater than the specified value."""
  greaterThan: TeamRole

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: TeamRole
}

enum TeamRole {
  OWNER
  ADMIN
  MEMBER
}

"""
A filter to be used against `Team` object types. All fields are combined with a logical ‘and.’
"""
input TeamFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `teamMembershipsByTeamId` relation."""
  teamMembershipsByTeamId: TeamToManyTeamMembershipFilter

  """Some related `teamMembershipsByTeamId` exist."""
  teamMembershipsByTeamIdExist: Boolean

  """Filter by the object’s `eventsByTeamId` relation."""
  eventsByTeamId: TeamToManyEventFilter

  """Some related `eventsByTeamId` exist."""
  eventsByTeamIdExist: Boolean

  """Checks for all expressions in this list."""
  and: [TeamFilter!]

  """Checks for any expressions in this list."""
  or: [TeamFilter!]

  """Negates the expression."""
  not: TeamFilter
}

"""
A filter to be used against many `TeamMembership` object types. All fields are combined with a logical ‘and.’
"""
input TeamToManyTeamMembershipFilter {
  """
  Every related `TeamMembership` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TeamMembershipFilter

  """
  Some related `TeamMembership` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TeamMembershipFilter

  """
  No related `TeamMembership` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TeamMembershipFilter

  """Aggregates across related `TeamMembership` match the filter criteria."""
  aggregates: TeamMembershipAggregatesFilter
}

"""
A filter to be used against aggregates of `TeamMembership` object types.
"""
input TeamMembershipAggregatesFilter {
  """
  A filter that must pass for the relevant `TeamMembership` object to be included within the aggregate.
  """
  filter: TeamMembershipFilter

  """Distinct count aggregate over matching `TeamMembership` objects."""
  distinctCount: TeamMembershipDistinctCountAggregateFilter
}

input TeamMembershipDistinctCountAggregateFilter {
  id: BigIntFilter
  userId: BigIntFilter
  teamId: BigIntFilter
  role: BigIntFilter
  createdAt: BigIntFilter
}

"""
A filter to be used against many `Event` object types. All fields are combined with a logical ‘and.’
"""
input TeamToManyEventFilter {
  """
  Every related `Event` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EventFilter

  """
  Some related `Event` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EventFilter

  """
  No related `Event` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EventFilter

  """Aggregates across related `Event` match the filter criteria."""
  aggregates: EventAggregatesFilter
}

"""
A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’
"""
input EventFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `duration` field."""
  duration: IntFilter

  """Filter by the object’s `location` field."""
  location: StringFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `teamId` field."""
  teamId: StringFilter

  """Filter by the object’s `bookingsByEventId` relation."""
  bookingsByEventId: EventToManyBookingFilter

  """Some related `bookingsByEventId` exist."""
  bookingsByEventIdExist: Boolean

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Filter by the object’s `team` relation."""
  team: TeamFilter

  """A related `team` exists."""
  teamExists: Boolean

  """Checks for all expressions in this list."""
  and: [EventFilter!]

  """Checks for any expressions in this list."""
  or: [EventFilter!]

  """Negates the expression."""
  not: EventFilter
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
A filter to be used against many `Booking` object types. All fields are combined with a logical ‘and.’
"""
input EventToManyBookingFilter {
  """
  Every related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BookingFilter

  """
  Some related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BookingFilter

  """
  No related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BookingFilter

  """Aggregates across related `Booking` match the filter criteria."""
  aggregates: BookingAggregatesFilter
}

"""
A filter to be used against `Booking` object types. All fields are combined with a logical ‘and.’
"""
input BookingFilter {
  """Filter by the object’s `eventId` field."""
  eventId: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `status` field."""
  status: BookingStatusFilter

  """Filter by the object’s `event` relation."""
  event: EventFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [BookingFilter!]

  """Checks for any expressions in this list."""
  or: [BookingFilter!]

  """Negates the expression."""
  not: BookingFilter
}

"""
A filter to be used against BookingStatus fields. All fields are combined with a logical ‘and.’
"""
input BookingStatusFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BookingStatus

  """Not equal to the specified value."""
  notEqualTo: BookingStatus

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BookingStatus

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BookingStatus

  """Included in the specified list."""
  in: [BookingStatus!]

  """Not included in the specified list."""
  notIn: [BookingStatus!]

  """Less than the specified value."""
  lessThan: BookingStatus

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BookingStatus

  """Greater than the specified value."""
  greaterThan: BookingStatus

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BookingStatus
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELED
}

"""A filter to be used against aggregates of `Booking` object types."""
input BookingAggregatesFilter {
  """
  A filter that must pass for the relevant `Booking` object to be included within the aggregate.
  """
  filter: BookingFilter

  """Distinct count aggregate over matching `Booking` objects."""
  distinctCount: BookingDistinctCountAggregateFilter
}

input BookingDistinctCountAggregateFilter {
  eventId: BigIntFilter
  userId: BigIntFilter
  status: BigIntFilter
}

"""A filter to be used against aggregates of `Event` object types."""
input EventAggregatesFilter {
  """
  A filter that must pass for the relevant `Event` object to be included within the aggregate.
  """
  filter: EventFilter

  """Sum aggregate over matching `Event` objects."""
  sum: EventSumAggregateFilter

  """Distinct count aggregate over matching `Event` objects."""
  distinctCount: EventDistinctCountAggregateFilter

  """Minimum aggregate over matching `Event` objects."""
  min: EventMinAggregateFilter

  """Maximum aggregate over matching `Event` objects."""
  max: EventMaxAggregateFilter

  """Mean average aggregate over matching `Event` objects."""
  average: EventAverageAggregateFilter

  """Sample standard deviation aggregate over matching `Event` objects."""
  stddevSample: EventStddevSampleAggregateFilter

  """Population standard deviation aggregate over matching `Event` objects."""
  stddevPopulation: EventStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Event` objects."""
  varianceSample: EventVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Event` objects."""
  variancePopulation: EventVariancePopulationAggregateFilter
}

input EventSumAggregateFilter {
  duration: BigIntFilter
}

input EventDistinctCountAggregateFilter {
  id: BigIntFilter
  title: BigIntFilter
  description: BigIntFilter
  duration: BigIntFilter
  location: BigIntFilter
  date: BigIntFilter
  userId: BigIntFilter
  teamId: BigIntFilter
}

input EventMinAggregateFilter {
  duration: IntFilter
}

input EventMaxAggregateFilter {
  duration: IntFilter
}

input EventAverageAggregateFilter {
  duration: BigFloatFilter
}

"""
A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’
"""
input BigFloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigFloat

  """Not equal to the specified value."""
  notEqualTo: BigFloat

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloat

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigFloat

  """Included in the specified list."""
  in: [BigFloat!]

  """Not included in the specified list."""
  notIn: [BigFloat!]

  """Less than the specified value."""
  lessThan: BigFloat

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigFloat

  """Greater than the specified value."""
  greaterThan: BigFloat

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigFloat
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

input EventStddevSampleAggregateFilter {
  duration: BigFloatFilter
}

input EventStddevPopulationAggregateFilter {
  duration: BigFloatFilter
}

input EventVarianceSampleAggregateFilter {
  duration: BigFloatFilter
}

input EventVariancePopulationAggregateFilter {
  duration: BigFloatFilter
}

"""
A filter to be used against many `Availability` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyAvailabilityFilter {
  """
  Every related `Availability` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AvailabilityFilter

  """
  Some related `Availability` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AvailabilityFilter

  """
  No related `Availability` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AvailabilityFilter

  """Aggregates across related `Availability` match the filter criteria."""
  aggregates: AvailabilityAggregatesFilter
}

"""
A filter to be used against `Availability` object types. All fields are combined with a logical ‘and.’
"""
input AvailabilityFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `dayOfWeek` field."""
  dayOfWeek: IntFilter

  """Filter by the object’s `startTime` field."""
  startTime: DatetimeFilter

  """Filter by the object’s `endTime` field."""
  endTime: DatetimeFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [AvailabilityFilter!]

  """Checks for any expressions in this list."""
  or: [AvailabilityFilter!]

  """Negates the expression."""
  not: AvailabilityFilter
}

"""A filter to be used against aggregates of `Availability` object types."""
input AvailabilityAggregatesFilter {
  """
  A filter that must pass for the relevant `Availability` object to be included within the aggregate.
  """
  filter: AvailabilityFilter

  """Sum aggregate over matching `Availability` objects."""
  sum: AvailabilitySumAggregateFilter

  """Distinct count aggregate over matching `Availability` objects."""
  distinctCount: AvailabilityDistinctCountAggregateFilter

  """Minimum aggregate over matching `Availability` objects."""
  min: AvailabilityMinAggregateFilter

  """Maximum aggregate over matching `Availability` objects."""
  max: AvailabilityMaxAggregateFilter

  """Mean average aggregate over matching `Availability` objects."""
  average: AvailabilityAverageAggregateFilter

  """
  Sample standard deviation aggregate over matching `Availability` objects.
  """
  stddevSample: AvailabilityStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `Availability` objects.
  """
  stddevPopulation: AvailabilityStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Availability` objects."""
  varianceSample: AvailabilityVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Availability` objects."""
  variancePopulation: AvailabilityVariancePopulationAggregateFilter
}

input AvailabilitySumAggregateFilter {
  dayOfWeek: BigIntFilter
}

input AvailabilityDistinctCountAggregateFilter {
  id: BigIntFilter
  userId: BigIntFilter
  dayOfWeek: BigIntFilter
  startTime: BigIntFilter
  endTime: BigIntFilter
}

input AvailabilityMinAggregateFilter {
  dayOfWeek: IntFilter
}

input AvailabilityMaxAggregateFilter {
  dayOfWeek: IntFilter
}

input AvailabilityAverageAggregateFilter {
  dayOfWeek: BigFloatFilter
}

input AvailabilityStddevSampleAggregateFilter {
  dayOfWeek: BigFloatFilter
}

input AvailabilityStddevPopulationAggregateFilter {
  dayOfWeek: BigFloatFilter
}

input AvailabilityVarianceSampleAggregateFilter {
  dayOfWeek: BigFloatFilter
}

input AvailabilityVariancePopulationAggregateFilter {
  dayOfWeek: BigFloatFilter
}

"""
A filter to be used against many `CustomAvailability` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyCustomAvailabilityFilter {
  """
  Every related `CustomAvailability` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CustomAvailabilityFilter

  """
  Some related `CustomAvailability` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CustomAvailabilityFilter

  """
  No related `CustomAvailability` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CustomAvailabilityFilter

  """
  Aggregates across related `CustomAvailability` match the filter criteria.
  """
  aggregates: CustomAvailabilityAggregatesFilter
}

"""
A filter to be used against `CustomAvailability` object types. All fields are combined with a logical ‘and.’
"""
input CustomAvailabilityFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `startTime` field."""
  startTime: DatetimeFilter

  """Filter by the object’s `endTime` field."""
  endTime: DatetimeFilter

  """Filter by the object’s `available` field."""
  available: BooleanFilter

  """Filter by the object’s `reason` field."""
  reason: StringFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [CustomAvailabilityFilter!]

  """Checks for any expressions in this list."""
  or: [CustomAvailabilityFilter!]

  """Negates the expression."""
  not: CustomAvailabilityFilter
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against aggregates of `CustomAvailability` object types.
"""
input CustomAvailabilityAggregatesFilter {
  """
  A filter that must pass for the relevant `CustomAvailability` object to be included within the aggregate.
  """
  filter: CustomAvailabilityFilter

  """Distinct count aggregate over matching `CustomAvailability` objects."""
  distinctCount: CustomAvailabilityDistinctCountAggregateFilter
}

input CustomAvailabilityDistinctCountAggregateFilter {
  id: BigIntFilter
  userId: BigIntFilter
  startTime: BigIntFilter
  endTime: BigIntFilter
  available: BigIntFilter
  reason: BigIntFilter
}

"""
A filter to be used against many `Event` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyEventFilter {
  """
  Every related `Event` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EventFilter

  """
  Some related `Event` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EventFilter

  """
  No related `Event` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EventFilter

  """Aggregates across related `Event` match the filter criteria."""
  aggregates: EventAggregatesFilter
}

"""
A filter to be used against many `Booking` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyBookingFilter {
  """
  Every related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BookingFilter

  """
  Some related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BookingFilter

  """
  No related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BookingFilter

  """Aggregates across related `Booking` match the filter criteria."""
  aggregates: BookingAggregatesFilter
}

"""A connection to a list of `TeamMembership` values."""
type TeamMembershipsConnection {
  """A list of `TeamMembership` objects."""
  nodes: [TeamMembership!]!

  """
  A list of edges which contains the `TeamMembership` and cursor to aid in pagination.
  """
  edges: [TeamMembershipsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TeamMembership` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TeamMembershipAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `TeamMembership` for these aggregates."""
    groupBy: [TeamMembershipGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TeamMembershipHavingInput
  ): [TeamMembershipAggregates!]
}

type TeamMembership implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  userId: String!
  teamId: String!
  role: TeamRole!
  createdAt: Datetime!

  """Reads a single `User` that is related to this `TeamMembership`."""
  user: User

  """Reads a single `Team` that is related to this `TeamMembership`."""
  team: Team
}

type Team implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `TeamMembership`."""
  teamMembershipsByTeamId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamMembership`."""
    orderBy: [TeamMembershipsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamMembershipCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TeamMembershipFilter
  ): TeamMembershipsConnection!

  """Reads and enables pagination through a set of `Event`."""
  eventsByTeamId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EventCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EventFilter
  ): EventsConnection!
}

"""Methods to use when ordering `TeamMembership`."""
enum TeamMembershipsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  ROLE_ASC
  ROLE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TeamMembership` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TeamMembershipCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `teamId` field."""
  teamId: String

  """Checks for equality with the object’s `role` field."""
  role: TeamRole

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime
}

"""A connection to a list of `Event` values."""
type EventsConnection {
  """A list of `Event` objects."""
  nodes: [Event!]!

  """
  A list of edges which contains the `Event` and cursor to aid in pagination.
  """
  edges: [EventsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Event` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: EventAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Event` for these aggregates."""
    groupBy: [EventGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: EventHavingInput
  ): [EventAggregates!]
}

type Event implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  title: String!
  description: String
  duration: Int!
  location: String
  date: Datetime!
  userId: String
  teamId: String

  """Reads a single `User` that is related to this `Event`."""
  user: User

  """Reads a single `Team` that is related to this `Event`."""
  team: Team

  """Reads and enables pagination through a set of `Booking`."""
  bookingsByEventId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter
  ): BookingsConnection!
}

"""A connection to a list of `Booking` values."""
type BookingsConnection {
  """A list of `Booking` objects."""
  nodes: [Booking!]!

  """
  A list of edges which contains the `Booking` and cursor to aid in pagination.
  """
  edges: [BookingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Booking` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: BookingAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Booking` for these aggregates."""
    groupBy: [BookingGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: BookingHavingInput
  ): [BookingAggregates!]
}

type Booking implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  eventId: String!
  userId: String!
  status: BookingStatus!

  """Reads a single `Event` that is related to this `Booking`."""
  event: Event

  """Reads a single `User` that is related to this `Booking`."""
  user: User
}

"""A `Booking` edge in the connection."""
type BookingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Booking` at the end of the edge."""
  node: Booking!
}

type BookingAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: BookingDistinctCountAggregates
}

type BookingDistinctCountAggregates {
  """Distinct count of eventId across the matching connection"""
  eventId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of status across the matching connection"""
  status: BigInt
}

"""Grouping methods for `Booking` for usage during aggregation."""
enum BookingGroupBy {
  EVENT_ID
  USER_ID
  STATUS
}

"""Conditions for `Booking` aggregates."""
input BookingHavingInput {
  AND: [BookingHavingInput!]
  OR: [BookingHavingInput!]
}

"""Methods to use when ordering `Booking`."""
enum BookingsOrderBy {
  NATURAL
  EVENT_ID_ASC
  EVENT_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  STATUS_ASC
  STATUS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Booking` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input BookingCondition {
  """Checks for equality with the object’s `eventId` field."""
  eventId: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `status` field."""
  status: BookingStatus
}

"""A `Event` edge in the connection."""
type EventsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Event` at the end of the edge."""
  node: Event!
}

type EventAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: EventSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: EventDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: EventMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: EventMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: EventAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: EventStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: EventStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: EventVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: EventVariancePopulationAggregates
}

type EventSumAggregates {
  """Sum of duration across the matching connection"""
  duration: BigInt!
}

type EventDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of duration across the matching connection"""
  duration: BigInt

  """Distinct count of location across the matching connection"""
  location: BigInt

  """Distinct count of date across the matching connection"""
  date: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of teamId across the matching connection"""
  teamId: BigInt
}

type EventMinAggregates {
  """Minimum of duration across the matching connection"""
  duration: Int
}

type EventMaxAggregates {
  """Maximum of duration across the matching connection"""
  duration: Int
}

type EventAverageAggregates {
  """Mean average of duration across the matching connection"""
  duration: BigFloat
}

type EventStddevSampleAggregates {
  """Sample standard deviation of duration across the matching connection"""
  duration: BigFloat
}

type EventStddevPopulationAggregates {
  """
  Population standard deviation of duration across the matching connection
  """
  duration: BigFloat
}

type EventVarianceSampleAggregates {
  """Sample variance of duration across the matching connection"""
  duration: BigFloat
}

type EventVariancePopulationAggregates {
  """Population variance of duration across the matching connection"""
  duration: BigFloat
}

"""Grouping methods for `Event` for usage during aggregation."""
enum EventGroupBy {
  TITLE
  DESCRIPTION
  DURATION
  LOCATION
  DATE
  DATE_TRUNCATED_TO_HOUR
  DATE_TRUNCATED_TO_DAY
  USER_ID
  TEAM_ID
}

"""Conditions for `Event` aggregates."""
input EventHavingInput {
  AND: [EventHavingInput!]
  OR: [EventHavingInput!]
  sum: EventHavingSumInput
  distinctCount: EventHavingDistinctCountInput
  min: EventHavingMinInput
  max: EventHavingMaxInput
  average: EventHavingAverageInput
  stddevSample: EventHavingStddevSampleInput
  stddevPopulation: EventHavingStddevPopulationInput
  varianceSample: EventHavingVarianceSampleInput
  variancePopulation: EventHavingVariancePopulationInput
}

input EventHavingSumInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

input HavingIntFilter {
  equalTo: Int
  notEqualTo: Int
  greaterThan: Int
  greaterThanOrEqualTo: Int
  lessThan: Int
  lessThanOrEqualTo: Int
}

input HavingDatetimeFilter {
  equalTo: Datetime
  notEqualTo: Datetime
  greaterThan: Datetime
  greaterThanOrEqualTo: Datetime
  lessThan: Datetime
  lessThanOrEqualTo: Datetime
}

input EventHavingDistinctCountInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

input EventHavingMinInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

input EventHavingMaxInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

input EventHavingAverageInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

input EventHavingStddevSampleInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

input EventHavingStddevPopulationInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

input EventHavingVarianceSampleInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

input EventHavingVariancePopulationInput {
  duration: HavingIntFilter
  date: HavingDatetimeFilter
}

"""Methods to use when ordering `Event`."""
enum EventsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  DURATION_ASC
  DURATION_DESC
  LOCATION_ASC
  LOCATION_DESC
  DATE_ASC
  DATE_DESC
  USER_ID_ASC
  USER_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  BOOKINGS_BY_EVENT_ID_COUNT_ASC
  BOOKINGS_BY_EVENT_ID_COUNT_DESC
  BOOKINGS_BY_EVENT_ID_SUM_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_SUM_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_SUM_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_SUM_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_SUM_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_SUM_STATUS_DESC
  BOOKINGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_DISTINCT_COUNT_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_DISTINCT_COUNT_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_DISTINCT_COUNT_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_DISTINCT_COUNT_STATUS_DESC
  BOOKINGS_BY_EVENT_ID_MIN_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_MIN_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_MIN_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_MIN_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_MIN_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_MIN_STATUS_DESC
  BOOKINGS_BY_EVENT_ID_MAX_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_MAX_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_MAX_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_MAX_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_MAX_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_MAX_STATUS_DESC
  BOOKINGS_BY_EVENT_ID_AVERAGE_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_AVERAGE_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_AVERAGE_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_AVERAGE_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_AVERAGE_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_AVERAGE_STATUS_DESC
  BOOKINGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_STDDEV_SAMPLE_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_STDDEV_SAMPLE_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_STDDEV_SAMPLE_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_STDDEV_SAMPLE_STATUS_DESC
  BOOKINGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_STDDEV_POPULATION_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_STDDEV_POPULATION_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_STDDEV_POPULATION_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_STDDEV_POPULATION_STATUS_DESC
  BOOKINGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_VARIANCE_SAMPLE_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_VARIANCE_SAMPLE_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_VARIANCE_SAMPLE_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_VARIANCE_SAMPLE_STATUS_DESC
  BOOKINGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_ID_ASC
  BOOKINGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_ID_DESC
  BOOKINGS_BY_EVENT_ID_VARIANCE_POPULATION_USER_ID_ASC
  BOOKINGS_BY_EVENT_ID_VARIANCE_POPULATION_USER_ID_DESC
  BOOKINGS_BY_EVENT_ID_VARIANCE_POPULATION_STATUS_ASC
  BOOKINGS_BY_EVENT_ID_VARIANCE_POPULATION_STATUS_DESC
}

"""
A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input EventCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `duration` field."""
  duration: Int

  """Checks for equality with the object’s `location` field."""
  location: String

  """Checks for equality with the object’s `date` field."""
  date: Datetime

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `teamId` field."""
  teamId: String
}

"""A `TeamMembership` edge in the connection."""
type TeamMembershipsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TeamMembership` at the end of the edge."""
  node: TeamMembership!
}

type TeamMembershipAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TeamMembershipDistinctCountAggregates
}

type TeamMembershipDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of teamId across the matching connection"""
  teamId: BigInt

  """Distinct count of role across the matching connection"""
  role: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt
}

"""Grouping methods for `TeamMembership` for usage during aggregation."""
enum TeamMembershipGroupBy {
  USER_ID
  TEAM_ID
  ROLE
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `TeamMembership` aggregates."""
input TeamMembershipHavingInput {
  AND: [TeamMembershipHavingInput!]
  OR: [TeamMembershipHavingInput!]
  sum: TeamMembershipHavingSumInput
  distinctCount: TeamMembershipHavingDistinctCountInput
  min: TeamMembershipHavingMinInput
  max: TeamMembershipHavingMaxInput
  average: TeamMembershipHavingAverageInput
  stddevSample: TeamMembershipHavingStddevSampleInput
  stddevPopulation: TeamMembershipHavingStddevPopulationInput
  varianceSample: TeamMembershipHavingVarianceSampleInput
  variancePopulation: TeamMembershipHavingVariancePopulationInput
}

input TeamMembershipHavingSumInput {
  createdAt: HavingDatetimeFilter
}

input TeamMembershipHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
}

input TeamMembershipHavingMinInput {
  createdAt: HavingDatetimeFilter
}

input TeamMembershipHavingMaxInput {
  createdAt: HavingDatetimeFilter
}

input TeamMembershipHavingAverageInput {
  createdAt: HavingDatetimeFilter
}

input TeamMembershipHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
}

input TeamMembershipHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
}

input TeamMembershipHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
}

input TeamMembershipHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
}

"""Methods to use when ordering `Availability`."""
enum AvailabilitiesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  DAY_OF_WEEK_ASC
  DAY_OF_WEEK_DESC
  START_TIME_ASC
  START_TIME_DESC
  END_TIME_ASC
  END_TIME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Availability` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AvailabilityCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `dayOfWeek` field."""
  dayOfWeek: Int

  """Checks for equality with the object’s `startTime` field."""
  startTime: Datetime

  """Checks for equality with the object’s `endTime` field."""
  endTime: Datetime
}

"""A connection to a list of `CustomAvailability` values."""
type CustomAvailabilitiesConnection {
  """A list of `CustomAvailability` objects."""
  nodes: [CustomAvailability!]!

  """
  A list of edges which contains the `CustomAvailability` and cursor to aid in pagination.
  """
  edges: [CustomAvailabilitiesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `CustomAvailability` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: CustomAvailabilityAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `CustomAvailability` for these aggregates.
    """
    groupBy: [CustomAvailabilityGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: CustomAvailabilityHavingInput
  ): [CustomAvailabilityAggregates!]
}

type CustomAvailability implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  userId: String!
  startTime: Datetime!
  endTime: Datetime!
  available: Boolean!
  reason: String

  """Reads a single `User` that is related to this `CustomAvailability`."""
  user: User
}

"""A `CustomAvailability` edge in the connection."""
type CustomAvailabilitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CustomAvailability` at the end of the edge."""
  node: CustomAvailability!
}

type CustomAvailabilityAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: CustomAvailabilityDistinctCountAggregates
}

type CustomAvailabilityDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of startTime across the matching connection"""
  startTime: BigInt

  """Distinct count of endTime across the matching connection"""
  endTime: BigInt

  """Distinct count of available across the matching connection"""
  available: BigInt

  """Distinct count of reason across the matching connection"""
  reason: BigInt
}

"""
Grouping methods for `CustomAvailability` for usage during aggregation.
"""
enum CustomAvailabilityGroupBy {
  USER_ID
  START_TIME
  START_TIME_TRUNCATED_TO_HOUR
  START_TIME_TRUNCATED_TO_DAY
  END_TIME
  END_TIME_TRUNCATED_TO_HOUR
  END_TIME_TRUNCATED_TO_DAY
  AVAILABLE
  REASON
}

"""Conditions for `CustomAvailability` aggregates."""
input CustomAvailabilityHavingInput {
  AND: [CustomAvailabilityHavingInput!]
  OR: [CustomAvailabilityHavingInput!]
  sum: CustomAvailabilityHavingSumInput
  distinctCount: CustomAvailabilityHavingDistinctCountInput
  min: CustomAvailabilityHavingMinInput
  max: CustomAvailabilityHavingMaxInput
  average: CustomAvailabilityHavingAverageInput
  stddevSample: CustomAvailabilityHavingStddevSampleInput
  stddevPopulation: CustomAvailabilityHavingStddevPopulationInput
  varianceSample: CustomAvailabilityHavingVarianceSampleInput
  variancePopulation: CustomAvailabilityHavingVariancePopulationInput
}

input CustomAvailabilityHavingSumInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input CustomAvailabilityHavingDistinctCountInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input CustomAvailabilityHavingMinInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input CustomAvailabilityHavingMaxInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input CustomAvailabilityHavingAverageInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input CustomAvailabilityHavingStddevSampleInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input CustomAvailabilityHavingStddevPopulationInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input CustomAvailabilityHavingVarianceSampleInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input CustomAvailabilityHavingVariancePopulationInput {
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

"""Methods to use when ordering `CustomAvailability`."""
enum CustomAvailabilitiesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  START_TIME_ASC
  START_TIME_DESC
  END_TIME_ASC
  END_TIME_DESC
  AVAILABLE_ASC
  AVAILABLE_DESC
  REASON_ASC
  REASON_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CustomAvailability` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CustomAvailabilityCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `startTime` field."""
  startTime: Datetime

  """Checks for equality with the object’s `endTime` field."""
  endTime: Datetime

  """Checks for equality with the object’s `available` field."""
  available: Boolean

  """Checks for equality with the object’s `reason` field."""
  reason: String
}

"""A `Availability` edge in the connection."""
type AvailabilitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Availability` at the end of the edge."""
  node: Availability!
}

type AvailabilityAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: AvailabilitySumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AvailabilityDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: AvailabilityMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: AvailabilityMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: AvailabilityAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: AvailabilityStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: AvailabilityStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: AvailabilityVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: AvailabilityVariancePopulationAggregates
}

type AvailabilitySumAggregates {
  """Sum of dayOfWeek across the matching connection"""
  dayOfWeek: BigInt!
}

type AvailabilityDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of dayOfWeek across the matching connection"""
  dayOfWeek: BigInt

  """Distinct count of startTime across the matching connection"""
  startTime: BigInt

  """Distinct count of endTime across the matching connection"""
  endTime: BigInt
}

type AvailabilityMinAggregates {
  """Minimum of dayOfWeek across the matching connection"""
  dayOfWeek: Int
}

type AvailabilityMaxAggregates {
  """Maximum of dayOfWeek across the matching connection"""
  dayOfWeek: Int
}

type AvailabilityAverageAggregates {
  """Mean average of dayOfWeek across the matching connection"""
  dayOfWeek: BigFloat
}

type AvailabilityStddevSampleAggregates {
  """Sample standard deviation of dayOfWeek across the matching connection"""
  dayOfWeek: BigFloat
}

type AvailabilityStddevPopulationAggregates {
  """
  Population standard deviation of dayOfWeek across the matching connection
  """
  dayOfWeek: BigFloat
}

type AvailabilityVarianceSampleAggregates {
  """Sample variance of dayOfWeek across the matching connection"""
  dayOfWeek: BigFloat
}

type AvailabilityVariancePopulationAggregates {
  """Population variance of dayOfWeek across the matching connection"""
  dayOfWeek: BigFloat
}

"""Grouping methods for `Availability` for usage during aggregation."""
enum AvailabilityGroupBy {
  USER_ID
  DAY_OF_WEEK
  START_TIME
  START_TIME_TRUNCATED_TO_HOUR
  START_TIME_TRUNCATED_TO_DAY
  END_TIME
  END_TIME_TRUNCATED_TO_HOUR
  END_TIME_TRUNCATED_TO_DAY
}

"""Conditions for `Availability` aggregates."""
input AvailabilityHavingInput {
  AND: [AvailabilityHavingInput!]
  OR: [AvailabilityHavingInput!]
  sum: AvailabilityHavingSumInput
  distinctCount: AvailabilityHavingDistinctCountInput
  min: AvailabilityHavingMinInput
  max: AvailabilityHavingMaxInput
  average: AvailabilityHavingAverageInput
  stddevSample: AvailabilityHavingStddevSampleInput
  stddevPopulation: AvailabilityHavingStddevPopulationInput
  varianceSample: AvailabilityHavingVarianceSampleInput
  variancePopulation: AvailabilityHavingVariancePopulationInput
}

input AvailabilityHavingSumInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input AvailabilityHavingDistinctCountInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input AvailabilityHavingMinInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input AvailabilityHavingMaxInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input AvailabilityHavingAverageInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input AvailabilityHavingStddevSampleInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input AvailabilityHavingStddevPopulationInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input AvailabilityHavingVarianceSampleInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

input AvailabilityHavingVariancePopulationInput {
  dayOfWeek: HavingIntFilter
  startTime: HavingDatetimeFilter
  endTime: HavingDatetimeFilter
}

"""A connection to a list of `Team` values."""
type TeamsConnection {
  """A list of `Team` objects."""
  nodes: [Team!]!

  """
  A list of edges which contains the `Team` and cursor to aid in pagination.
  """
  edges: [TeamsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Team` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TeamAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Team` for these aggregates."""
    groupBy: [TeamGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TeamHavingInput
  ): [TeamAggregates!]
}

"""A `Team` edge in the connection."""
type TeamsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Team` at the end of the edge."""
  node: Team!
}

type TeamAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TeamDistinctCountAggregates
}

type TeamDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `Team` for usage during aggregation."""
enum TeamGroupBy {
  NAME
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Team` aggregates."""
input TeamHavingInput {
  AND: [TeamHavingInput!]
  OR: [TeamHavingInput!]
  sum: TeamHavingSumInput
  distinctCount: TeamHavingDistinctCountInput
  min: TeamHavingMinInput
  max: TeamHavingMaxInput
  average: TeamHavingAverageInput
  stddevSample: TeamHavingStddevSampleInput
  stddevPopulation: TeamHavingStddevPopulationInput
  varianceSample: TeamHavingVarianceSampleInput
  variancePopulation: TeamHavingVariancePopulationInput
}

input TeamHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TeamHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TeamHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TeamHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TeamHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TeamHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TeamHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TeamHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TeamHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering `Team`."""
enum TeamsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_COUNT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_COUNT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_SUM_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_DISTINCT_COUNT_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MIN_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_MAX_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_AVERAGE_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_SAMPLE_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_STDDEV_POPULATION_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_SAMPLE_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_TEAM_ID_VARIANCE_POPULATION_CREATED_AT_DESC
  EVENTS_BY_TEAM_ID_COUNT_ASC
  EVENTS_BY_TEAM_ID_COUNT_DESC
  EVENTS_BY_TEAM_ID_SUM_ID_ASC
  EVENTS_BY_TEAM_ID_SUM_ID_DESC
  EVENTS_BY_TEAM_ID_SUM_TITLE_ASC
  EVENTS_BY_TEAM_ID_SUM_TITLE_DESC
  EVENTS_BY_TEAM_ID_SUM_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_SUM_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_SUM_DURATION_ASC
  EVENTS_BY_TEAM_ID_SUM_DURATION_DESC
  EVENTS_BY_TEAM_ID_SUM_LOCATION_ASC
  EVENTS_BY_TEAM_ID_SUM_LOCATION_DESC
  EVENTS_BY_TEAM_ID_SUM_DATE_ASC
  EVENTS_BY_TEAM_ID_SUM_DATE_DESC
  EVENTS_BY_TEAM_ID_SUM_USER_ID_ASC
  EVENTS_BY_TEAM_ID_SUM_USER_ID_DESC
  EVENTS_BY_TEAM_ID_SUM_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_SUM_TEAM_ID_DESC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_ID_ASC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_ID_DESC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_TITLE_ASC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_TITLE_DESC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_DURATION_ASC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_DURATION_DESC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_LOCATION_ASC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_LOCATION_DESC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_DATE_ASC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_DATE_DESC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_USER_ID_ASC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_USER_ID_DESC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_DISTINCT_COUNT_TEAM_ID_DESC
  EVENTS_BY_TEAM_ID_MIN_ID_ASC
  EVENTS_BY_TEAM_ID_MIN_ID_DESC
  EVENTS_BY_TEAM_ID_MIN_TITLE_ASC
  EVENTS_BY_TEAM_ID_MIN_TITLE_DESC
  EVENTS_BY_TEAM_ID_MIN_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_MIN_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_MIN_DURATION_ASC
  EVENTS_BY_TEAM_ID_MIN_DURATION_DESC
  EVENTS_BY_TEAM_ID_MIN_LOCATION_ASC
  EVENTS_BY_TEAM_ID_MIN_LOCATION_DESC
  EVENTS_BY_TEAM_ID_MIN_DATE_ASC
  EVENTS_BY_TEAM_ID_MIN_DATE_DESC
  EVENTS_BY_TEAM_ID_MIN_USER_ID_ASC
  EVENTS_BY_TEAM_ID_MIN_USER_ID_DESC
  EVENTS_BY_TEAM_ID_MIN_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_MIN_TEAM_ID_DESC
  EVENTS_BY_TEAM_ID_MAX_ID_ASC
  EVENTS_BY_TEAM_ID_MAX_ID_DESC
  EVENTS_BY_TEAM_ID_MAX_TITLE_ASC
  EVENTS_BY_TEAM_ID_MAX_TITLE_DESC
  EVENTS_BY_TEAM_ID_MAX_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_MAX_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_MAX_DURATION_ASC
  EVENTS_BY_TEAM_ID_MAX_DURATION_DESC
  EVENTS_BY_TEAM_ID_MAX_LOCATION_ASC
  EVENTS_BY_TEAM_ID_MAX_LOCATION_DESC
  EVENTS_BY_TEAM_ID_MAX_DATE_ASC
  EVENTS_BY_TEAM_ID_MAX_DATE_DESC
  EVENTS_BY_TEAM_ID_MAX_USER_ID_ASC
  EVENTS_BY_TEAM_ID_MAX_USER_ID_DESC
  EVENTS_BY_TEAM_ID_MAX_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_MAX_TEAM_ID_DESC
  EVENTS_BY_TEAM_ID_AVERAGE_ID_ASC
  EVENTS_BY_TEAM_ID_AVERAGE_ID_DESC
  EVENTS_BY_TEAM_ID_AVERAGE_TITLE_ASC
  EVENTS_BY_TEAM_ID_AVERAGE_TITLE_DESC
  EVENTS_BY_TEAM_ID_AVERAGE_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_AVERAGE_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_AVERAGE_DURATION_ASC
  EVENTS_BY_TEAM_ID_AVERAGE_DURATION_DESC
  EVENTS_BY_TEAM_ID_AVERAGE_LOCATION_ASC
  EVENTS_BY_TEAM_ID_AVERAGE_LOCATION_DESC
  EVENTS_BY_TEAM_ID_AVERAGE_DATE_ASC
  EVENTS_BY_TEAM_ID_AVERAGE_DATE_DESC
  EVENTS_BY_TEAM_ID_AVERAGE_USER_ID_ASC
  EVENTS_BY_TEAM_ID_AVERAGE_USER_ID_DESC
  EVENTS_BY_TEAM_ID_AVERAGE_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_AVERAGE_TEAM_ID_DESC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_ID_ASC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_ID_DESC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_TITLE_ASC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_TITLE_DESC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_DURATION_ASC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_DURATION_DESC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_LOCATION_ASC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_LOCATION_DESC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_DATE_ASC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_DATE_DESC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_USER_ID_ASC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_USER_ID_DESC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_STDDEV_SAMPLE_TEAM_ID_DESC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_ID_ASC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_ID_DESC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_TITLE_ASC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_TITLE_DESC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_DURATION_ASC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_DURATION_DESC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_LOCATION_ASC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_LOCATION_DESC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_DATE_ASC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_DATE_DESC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_USER_ID_ASC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_USER_ID_DESC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_STDDEV_POPULATION_TEAM_ID_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_ID_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_ID_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_TITLE_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_TITLE_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_DURATION_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_DURATION_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_LOCATION_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_LOCATION_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_DATE_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_DATE_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_USER_ID_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_USER_ID_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_SAMPLE_TEAM_ID_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_ID_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_ID_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_TITLE_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_TITLE_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_DESCRIPTION_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_DESCRIPTION_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_DURATION_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_DURATION_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_LOCATION_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_LOCATION_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_DATE_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_DATE_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_USER_ID_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_USER_ID_DESC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_TEAM_ID_ASC
  EVENTS_BY_TEAM_ID_VARIANCE_POPULATION_TEAM_ID_DESC
}

"""
A condition to be used against `Team` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TeamCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `User` for these aggregates."""
    groupBy: [UserGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserHavingInput
  ): [UserAggregates!]
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

type UserAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDistinctCountAggregates
}

type UserDistinctCountAggregates {
  """Distinct count of oidcId across the matching connection"""
  oidcId: BigInt

  """Distinct count of firstName across the matching connection"""
  firstName: BigInt

  """Distinct count of lastName across the matching connection"""
  lastName: BigInt

  """Distinct count of gender across the matching connection"""
  gender: BigInt

  """Distinct count of birthDay across the matching connection"""
  birthDay: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt

  """Distinct count of tel across the matching connection"""
  tel: BigInt

  """Distinct count of picture across the matching connection"""
  picture: BigInt
}

"""Grouping methods for `User` for usage during aggregation."""
enum UserGroupBy {
  FIRST_NAME
  LAST_NAME
  GENDER
  BIRTH_DAY
  BIRTH_DAY_TRUNCATED_TO_HOUR
  BIRTH_DAY_TRUNCATED_TO_DAY
  EMAIL
  TEL
  PICTURE
}

"""Conditions for `User` aggregates."""
input UserHavingInput {
  AND: [UserHavingInput!]
  OR: [UserHavingInput!]
  sum: UserHavingSumInput
  distinctCount: UserHavingDistinctCountInput
  min: UserHavingMinInput
  max: UserHavingMaxInput
  average: UserHavingAverageInput
  stddevSample: UserHavingStddevSampleInput
  stddevPopulation: UserHavingStddevPopulationInput
  varianceSample: UserHavingVarianceSampleInput
  variancePopulation: UserHavingVariancePopulationInput
}

input UserHavingSumInput {
  birthDay: HavingDatetimeFilter
}

input UserHavingDistinctCountInput {
  birthDay: HavingDatetimeFilter
}

input UserHavingMinInput {
  birthDay: HavingDatetimeFilter
}

input UserHavingMaxInput {
  birthDay: HavingDatetimeFilter
}

input UserHavingAverageInput {
  birthDay: HavingDatetimeFilter
}

input UserHavingStddevSampleInput {
  birthDay: HavingDatetimeFilter
}

input UserHavingStddevPopulationInput {
  birthDay: HavingDatetimeFilter
}

input UserHavingVarianceSampleInput {
  birthDay: HavingDatetimeFilter
}

input UserHavingVariancePopulationInput {
  birthDay: HavingDatetimeFilter
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  OIDC_ID_ASC
  OIDC_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  GENDER_ASC
  GENDER_DESC
  BIRTH_DAY_ASC
  BIRTH_DAY_DESC
  EMAIL_ASC
  EMAIL_DESC
  TEL_ASC
  TEL_DESC
  PICTURE_ASC
  PICTURE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_DEVICES_BY_USER_ID_COUNT_ASC
  USER_DEVICES_BY_USER_ID_COUNT_DESC
  USER_DEVICES_BY_USER_ID_SUM_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_SUM_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_SUM_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_SUM_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_SUM_UA_ASC
  USER_DEVICES_BY_USER_ID_SUM_UA_DESC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_UA_ASC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_UA_DESC
  USER_DEVICES_BY_USER_ID_MIN_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_MIN_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_MIN_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_MIN_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_MIN_UA_ASC
  USER_DEVICES_BY_USER_ID_MIN_UA_DESC
  USER_DEVICES_BY_USER_ID_MAX_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_MAX_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_MAX_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_MAX_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_MAX_UA_ASC
  USER_DEVICES_BY_USER_ID_MAX_UA_DESC
  USER_DEVICES_BY_USER_ID_AVERAGE_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_AVERAGE_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_AVERAGE_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_AVERAGE_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_AVERAGE_UA_ASC
  USER_DEVICES_BY_USER_ID_AVERAGE_UA_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_UA_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_UA_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_UA_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_UA_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_UA_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_UA_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_UA_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_UA_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_COUNT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_COUNT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_SUM_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_DISTINCT_COUNT_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MIN_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_MAX_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_AVERAGE_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_SAMPLE_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_STDDEV_POPULATION_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_SAMPLE_CREATED_AT_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_TEAM_ID_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_TEAM_ID_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_ROLE_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_ROLE_DESC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_CREATED_AT_ASC
  TEAM_MEMBERSHIPS_BY_USER_ID_VARIANCE_POPULATION_CREATED_AT_DESC
  AVAILABILITIES_BY_USER_ID_COUNT_ASC
  AVAILABILITIES_BY_USER_ID_COUNT_DESC
  AVAILABILITIES_BY_USER_ID_SUM_ID_ASC
  AVAILABILITIES_BY_USER_ID_SUM_ID_DESC
  AVAILABILITIES_BY_USER_ID_SUM_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_SUM_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_SUM_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_SUM_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_SUM_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_SUM_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_SUM_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_SUM_END_TIME_DESC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_ID_ASC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_ID_DESC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_END_TIME_DESC
  AVAILABILITIES_BY_USER_ID_MIN_ID_ASC
  AVAILABILITIES_BY_USER_ID_MIN_ID_DESC
  AVAILABILITIES_BY_USER_ID_MIN_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_MIN_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_MIN_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_MIN_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_MIN_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_MIN_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_MIN_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_MIN_END_TIME_DESC
  AVAILABILITIES_BY_USER_ID_MAX_ID_ASC
  AVAILABILITIES_BY_USER_ID_MAX_ID_DESC
  AVAILABILITIES_BY_USER_ID_MAX_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_MAX_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_MAX_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_MAX_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_MAX_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_MAX_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_MAX_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_MAX_END_TIME_DESC
  AVAILABILITIES_BY_USER_ID_AVERAGE_ID_ASC
  AVAILABILITIES_BY_USER_ID_AVERAGE_ID_DESC
  AVAILABILITIES_BY_USER_ID_AVERAGE_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_AVERAGE_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_AVERAGE_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_AVERAGE_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_AVERAGE_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_AVERAGE_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_AVERAGE_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_AVERAGE_END_TIME_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_ID_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_ID_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_END_TIME_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_ID_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_ID_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_END_TIME_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_ID_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_ID_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_END_TIME_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_ID_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_ID_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_DAY_OF_WEEK_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_DAY_OF_WEEK_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_START_TIME_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_START_TIME_DESC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_END_TIME_ASC
  AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_COUNT_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_COUNT_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_SUM_REASON_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_DISTINCT_COUNT_REASON_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MIN_REASON_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_MAX_REASON_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_AVERAGE_REASON_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_SAMPLE_REASON_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_STDDEV_POPULATION_REASON_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_SAMPLE_REASON_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_START_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_START_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_END_TIME_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_END_TIME_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_AVAILABLE_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_AVAILABLE_DESC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_REASON_ASC
  CUSTOM_AVAILABILITIES_BY_USER_ID_VARIANCE_POPULATION_REASON_DESC
  EVENTS_BY_USER_ID_COUNT_ASC
  EVENTS_BY_USER_ID_COUNT_DESC
  EVENTS_BY_USER_ID_SUM_ID_ASC
  EVENTS_BY_USER_ID_SUM_ID_DESC
  EVENTS_BY_USER_ID_SUM_TITLE_ASC
  EVENTS_BY_USER_ID_SUM_TITLE_DESC
  EVENTS_BY_USER_ID_SUM_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_SUM_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_SUM_DURATION_ASC
  EVENTS_BY_USER_ID_SUM_DURATION_DESC
  EVENTS_BY_USER_ID_SUM_LOCATION_ASC
  EVENTS_BY_USER_ID_SUM_LOCATION_DESC
  EVENTS_BY_USER_ID_SUM_DATE_ASC
  EVENTS_BY_USER_ID_SUM_DATE_DESC
  EVENTS_BY_USER_ID_SUM_USER_ID_ASC
  EVENTS_BY_USER_ID_SUM_USER_ID_DESC
  EVENTS_BY_USER_ID_SUM_TEAM_ID_ASC
  EVENTS_BY_USER_ID_SUM_TEAM_ID_DESC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_ID_ASC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_ID_DESC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_TITLE_ASC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_TITLE_DESC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_DURATION_ASC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_DURATION_DESC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_LOCATION_ASC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_LOCATION_DESC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_DATE_ASC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_DATE_DESC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_TEAM_ID_ASC
  EVENTS_BY_USER_ID_DISTINCT_COUNT_TEAM_ID_DESC
  EVENTS_BY_USER_ID_MIN_ID_ASC
  EVENTS_BY_USER_ID_MIN_ID_DESC
  EVENTS_BY_USER_ID_MIN_TITLE_ASC
  EVENTS_BY_USER_ID_MIN_TITLE_DESC
  EVENTS_BY_USER_ID_MIN_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_MIN_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_MIN_DURATION_ASC
  EVENTS_BY_USER_ID_MIN_DURATION_DESC
  EVENTS_BY_USER_ID_MIN_LOCATION_ASC
  EVENTS_BY_USER_ID_MIN_LOCATION_DESC
  EVENTS_BY_USER_ID_MIN_DATE_ASC
  EVENTS_BY_USER_ID_MIN_DATE_DESC
  EVENTS_BY_USER_ID_MIN_USER_ID_ASC
  EVENTS_BY_USER_ID_MIN_USER_ID_DESC
  EVENTS_BY_USER_ID_MIN_TEAM_ID_ASC
  EVENTS_BY_USER_ID_MIN_TEAM_ID_DESC
  EVENTS_BY_USER_ID_MAX_ID_ASC
  EVENTS_BY_USER_ID_MAX_ID_DESC
  EVENTS_BY_USER_ID_MAX_TITLE_ASC
  EVENTS_BY_USER_ID_MAX_TITLE_DESC
  EVENTS_BY_USER_ID_MAX_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_MAX_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_MAX_DURATION_ASC
  EVENTS_BY_USER_ID_MAX_DURATION_DESC
  EVENTS_BY_USER_ID_MAX_LOCATION_ASC
  EVENTS_BY_USER_ID_MAX_LOCATION_DESC
  EVENTS_BY_USER_ID_MAX_DATE_ASC
  EVENTS_BY_USER_ID_MAX_DATE_DESC
  EVENTS_BY_USER_ID_MAX_USER_ID_ASC
  EVENTS_BY_USER_ID_MAX_USER_ID_DESC
  EVENTS_BY_USER_ID_MAX_TEAM_ID_ASC
  EVENTS_BY_USER_ID_MAX_TEAM_ID_DESC
  EVENTS_BY_USER_ID_AVERAGE_ID_ASC
  EVENTS_BY_USER_ID_AVERAGE_ID_DESC
  EVENTS_BY_USER_ID_AVERAGE_TITLE_ASC
  EVENTS_BY_USER_ID_AVERAGE_TITLE_DESC
  EVENTS_BY_USER_ID_AVERAGE_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_AVERAGE_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_AVERAGE_DURATION_ASC
  EVENTS_BY_USER_ID_AVERAGE_DURATION_DESC
  EVENTS_BY_USER_ID_AVERAGE_LOCATION_ASC
  EVENTS_BY_USER_ID_AVERAGE_LOCATION_DESC
  EVENTS_BY_USER_ID_AVERAGE_DATE_ASC
  EVENTS_BY_USER_ID_AVERAGE_DATE_DESC
  EVENTS_BY_USER_ID_AVERAGE_USER_ID_ASC
  EVENTS_BY_USER_ID_AVERAGE_USER_ID_DESC
  EVENTS_BY_USER_ID_AVERAGE_TEAM_ID_ASC
  EVENTS_BY_USER_ID_AVERAGE_TEAM_ID_DESC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_ID_ASC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_ID_DESC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_TITLE_ASC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_TITLE_DESC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_DURATION_ASC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_DURATION_DESC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_LOCATION_ASC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_LOCATION_DESC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_DATE_ASC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_DATE_DESC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_TEAM_ID_ASC
  EVENTS_BY_USER_ID_STDDEV_SAMPLE_TEAM_ID_DESC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_ID_ASC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_ID_DESC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_TITLE_ASC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_TITLE_DESC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_DURATION_ASC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_DURATION_DESC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_LOCATION_ASC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_LOCATION_DESC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_DATE_ASC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_DATE_DESC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_TEAM_ID_ASC
  EVENTS_BY_USER_ID_STDDEV_POPULATION_TEAM_ID_DESC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_ID_ASC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_ID_DESC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_TITLE_ASC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_TITLE_DESC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_DURATION_ASC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_DURATION_DESC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_LOCATION_ASC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_LOCATION_DESC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_DATE_ASC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_DATE_DESC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_TEAM_ID_ASC
  EVENTS_BY_USER_ID_VARIANCE_SAMPLE_TEAM_ID_DESC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_ID_ASC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_ID_DESC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_TITLE_ASC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_TITLE_DESC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_DESCRIPTION_ASC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_DESCRIPTION_DESC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_DURATION_ASC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_DURATION_DESC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_LOCATION_ASC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_LOCATION_DESC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_DATE_ASC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_DATE_DESC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_TEAM_ID_ASC
  EVENTS_BY_USER_ID_VARIANCE_POPULATION_TEAM_ID_DESC
  BOOKINGS_BY_USER_ID_COUNT_ASC
  BOOKINGS_BY_USER_ID_COUNT_DESC
  BOOKINGS_BY_USER_ID_SUM_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_SUM_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_SUM_USER_ID_ASC
  BOOKINGS_BY_USER_ID_SUM_USER_ID_DESC
  BOOKINGS_BY_USER_ID_SUM_STATUS_ASC
  BOOKINGS_BY_USER_ID_SUM_STATUS_DESC
  BOOKINGS_BY_USER_ID_DISTINCT_COUNT_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_DISTINCT_COUNT_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  BOOKINGS_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  BOOKINGS_BY_USER_ID_DISTINCT_COUNT_STATUS_ASC
  BOOKINGS_BY_USER_ID_DISTINCT_COUNT_STATUS_DESC
  BOOKINGS_BY_USER_ID_MIN_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_MIN_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_MIN_USER_ID_ASC
  BOOKINGS_BY_USER_ID_MIN_USER_ID_DESC
  BOOKINGS_BY_USER_ID_MIN_STATUS_ASC
  BOOKINGS_BY_USER_ID_MIN_STATUS_DESC
  BOOKINGS_BY_USER_ID_MAX_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_MAX_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_MAX_USER_ID_ASC
  BOOKINGS_BY_USER_ID_MAX_USER_ID_DESC
  BOOKINGS_BY_USER_ID_MAX_STATUS_ASC
  BOOKINGS_BY_USER_ID_MAX_STATUS_DESC
  BOOKINGS_BY_USER_ID_AVERAGE_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_AVERAGE_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_AVERAGE_USER_ID_ASC
  BOOKINGS_BY_USER_ID_AVERAGE_USER_ID_DESC
  BOOKINGS_BY_USER_ID_AVERAGE_STATUS_ASC
  BOOKINGS_BY_USER_ID_AVERAGE_STATUS_DESC
  BOOKINGS_BY_USER_ID_STDDEV_SAMPLE_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_STDDEV_SAMPLE_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  BOOKINGS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  BOOKINGS_BY_USER_ID_STDDEV_SAMPLE_STATUS_ASC
  BOOKINGS_BY_USER_ID_STDDEV_SAMPLE_STATUS_DESC
  BOOKINGS_BY_USER_ID_STDDEV_POPULATION_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_STDDEV_POPULATION_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  BOOKINGS_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  BOOKINGS_BY_USER_ID_STDDEV_POPULATION_STATUS_ASC
  BOOKINGS_BY_USER_ID_STDDEV_POPULATION_STATUS_DESC
  BOOKINGS_BY_USER_ID_VARIANCE_SAMPLE_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_VARIANCE_SAMPLE_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  BOOKINGS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  BOOKINGS_BY_USER_ID_VARIANCE_SAMPLE_STATUS_ASC
  BOOKINGS_BY_USER_ID_VARIANCE_SAMPLE_STATUS_DESC
  BOOKINGS_BY_USER_ID_VARIANCE_POPULATION_EVENT_ID_ASC
  BOOKINGS_BY_USER_ID_VARIANCE_POPULATION_EVENT_ID_DESC
  BOOKINGS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  BOOKINGS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  BOOKINGS_BY_USER_ID_VARIANCE_POPULATION_STATUS_ASC
  BOOKINGS_BY_USER_ID_VARIANCE_POPULATION_STATUS_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `oidcId` field."""
  oidcId: String

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `gender` field."""
  gender: UserGender

  """Checks for equality with the object’s `birthDay` field."""
  birthDay: Datetime

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `tel` field."""
  tel: String

  """Checks for equality with the object’s `picture` field."""
  picture: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Availability`."""
  createAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAvailabilityInput!
  ): CreateAvailabilityPayload

  """Creates a single `Booking`."""
  createBooking(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateBookingInput!
  ): CreateBookingPayload

  """Creates a single `CustomAvailability`."""
  createCustomAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCustomAvailabilityInput!
  ): CreateCustomAvailabilityPayload

  """Creates a single `Event`."""
  createEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateEventInput!
  ): CreateEventPayload

  """Creates a single `Team`."""
  createTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeamInput!
  ): CreateTeamPayload

  """Creates a single `TeamMembership`."""
  createTeamMembership(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeamMembershipInput!
  ): CreateTeamMembershipPayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single `UserDevice`."""
  createUserDevice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserDeviceInput!
  ): CreateUserDevicePayload

  """
  Updates a single `Availability` using its globally unique id and a patch.
  """
  updateAvailabilityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAvailabilityByNodeIdInput!
  ): UpdateAvailabilityPayload

  """Updates a single `Availability` using a unique key and a patch."""
  updateAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAvailabilityInput!
  ): UpdateAvailabilityPayload

  """Updates a single `Booking` using its globally unique id and a patch."""
  updateBookingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBookingByNodeIdInput!
  ): UpdateBookingPayload

  """Updates a single `Booking` using a unique key and a patch."""
  updateBooking(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBookingInput!
  ): UpdateBookingPayload

  """
  Updates a single `CustomAvailability` using its globally unique id and a patch.
  """
  updateCustomAvailabilityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCustomAvailabilityByNodeIdInput!
  ): UpdateCustomAvailabilityPayload

  """Updates a single `CustomAvailability` using a unique key and a patch."""
  updateCustomAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCustomAvailabilityInput!
  ): UpdateCustomAvailabilityPayload

  """Updates a single `Event` using its globally unique id and a patch."""
  updateEventByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEventByNodeIdInput!
  ): UpdateEventPayload

  """Updates a single `Event` using a unique key and a patch."""
  updateEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEventInput!
  ): UpdateEventPayload

  """Updates a single `Team` using its globally unique id and a patch."""
  updateTeamByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamByNodeIdInput!
  ): UpdateTeamPayload

  """Updates a single `Team` using a unique key and a patch."""
  updateTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamInput!
  ): UpdateTeamPayload

  """
  Updates a single `TeamMembership` using its globally unique id and a patch.
  """
  updateTeamMembershipByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamMembershipByNodeIdInput!
  ): UpdateTeamMembershipPayload

  """Updates a single `TeamMembership` using a unique key and a patch."""
  updateTeamMembership(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamMembershipInput!
  ): UpdateTeamMembershipPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """
  Updates a single `UserDevice` using its globally unique id and a patch.
  """
  updateUserDeviceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserDeviceByNodeIdInput!
  ): UpdateUserDevicePayload

  """Updates a single `UserDevice` using a unique key and a patch."""
  updateUserDevice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserDeviceInput!
  ): UpdateUserDevicePayload

  """Updates a single `UserDevice` using a unique key and a patch."""
  updateUserDeviceByToken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserDeviceByTokenInput!
  ): UpdateUserDevicePayload

  """Deletes a single `Availability` using its globally unique id."""
  deleteAvailabilityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAvailabilityByNodeIdInput!
  ): DeleteAvailabilityPayload

  """Deletes a single `Availability` using a unique key."""
  deleteAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAvailabilityInput!
  ): DeleteAvailabilityPayload

  """Deletes a single `Booking` using its globally unique id."""
  deleteBookingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBookingByNodeIdInput!
  ): DeleteBookingPayload

  """Deletes a single `Booking` using a unique key."""
  deleteBooking(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBookingInput!
  ): DeleteBookingPayload

  """Deletes a single `CustomAvailability` using its globally unique id."""
  deleteCustomAvailabilityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCustomAvailabilityByNodeIdInput!
  ): DeleteCustomAvailabilityPayload

  """Deletes a single `CustomAvailability` using a unique key."""
  deleteCustomAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCustomAvailabilityInput!
  ): DeleteCustomAvailabilityPayload

  """Deletes a single `Event` using its globally unique id."""
  deleteEventByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEventByNodeIdInput!
  ): DeleteEventPayload

  """Deletes a single `Event` using a unique key."""
  deleteEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEventInput!
  ): DeleteEventPayload

  """Deletes a single `Team` using its globally unique id."""
  deleteTeamByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamByNodeIdInput!
  ): DeleteTeamPayload

  """Deletes a single `Team` using a unique key."""
  deleteTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamInput!
  ): DeleteTeamPayload

  """Deletes a single `TeamMembership` using its globally unique id."""
  deleteTeamMembershipByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamMembershipByNodeIdInput!
  ): DeleteTeamMembershipPayload

  """Deletes a single `TeamMembership` using a unique key."""
  deleteTeamMembership(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamMembershipInput!
  ): DeleteTeamMembershipPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByNodeIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single `UserDevice` using its globally unique id."""
  deleteUserDeviceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserDeviceByNodeIdInput!
  ): DeleteUserDevicePayload

  """Deletes a single `UserDevice` using a unique key."""
  deleteUserDevice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserDeviceInput!
  ): DeleteUserDevicePayload

  """Deletes a single `UserDevice` using a unique key."""
  deleteUserDeviceByToken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserDeviceByTokenInput!
  ): DeleteUserDevicePayload

  """Upserts a single `Availability`."""
  upsertAvailability(
    where: UpsertAvailabilityWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAvailabilityInput!
  ): UpsertAvailabilityPayload

  """Upserts a single `Booking`."""
  upsertBooking(
    where: UpsertBookingWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertBookingInput!
  ): UpsertBookingPayload

  """Upserts a single `CustomAvailability`."""
  upsertCustomAvailability(
    where: UpsertCustomAvailabilityWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertCustomAvailabilityInput!
  ): UpsertCustomAvailabilityPayload

  """Upserts a single `Event`."""
  upsertEvent(
    where: UpsertEventWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertEventInput!
  ): UpsertEventPayload

  """Upserts a single `Team`."""
  upsertTeam(
    where: UpsertTeamWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertTeamInput!
  ): UpsertTeamPayload

  """Upserts a single `TeamMembership`."""
  upsertTeamMembership(
    where: UpsertTeamMembershipWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertTeamMembershipInput!
  ): UpsertTeamMembershipPayload

  """Upserts a single `User`."""
  upsertUser(
    where: UpsertUserWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserInput!
  ): UpsertUserPayload

  """Upserts a single `UserDevice`."""
  upsertUserDevice(
    where: UpsertUserDeviceWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserDeviceInput!
  ): UpsertUserDevicePayload
}

"""The output of our create `Availability` mutation."""
type CreateAvailabilityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Availability` that was created by this mutation."""
  availability: Availability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Availability`."""
  user: User

  """An edge for our `Availability`. May be used by Relay 1."""
  availabilityEdge(
    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesEdge
}

"""All input for the create `Availability` mutation."""
input CreateAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Availability` to be created by this mutation."""
  availability: AvailabilityInput!
}

"""An input for mutations affecting `Availability`"""
input AvailabilityInput {
  id: String!
  userId: String!
  dayOfWeek: Int!
  startTime: Datetime
  endTime: Datetime
}

"""The output of our create `Booking` mutation."""
type CreateBookingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Booking` that was created by this mutation."""
  booking: Booking

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Booking`."""
  event: Event

  """Reads a single `User` that is related to this `Booking`."""
  user: User

  """An edge for our `Booking`. May be used by Relay 1."""
  bookingEdge(
    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsEdge
}

"""All input for the create `Booking` mutation."""
input CreateBookingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Booking` to be created by this mutation."""
  booking: BookingInput!
}

"""An input for mutations affecting `Booking`"""
input BookingInput {
  eventId: String!
  userId: String!
  status: BookingStatus
}

"""The output of our create `CustomAvailability` mutation."""
type CreateCustomAvailabilityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CustomAvailability` that was created by this mutation."""
  customAvailability: CustomAvailability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `CustomAvailability`."""
  user: User

  """An edge for our `CustomAvailability`. May be used by Relay 1."""
  customAvailabilityEdge(
    """The method to use when ordering `CustomAvailability`."""
    orderBy: [CustomAvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomAvailabilitiesEdge
}

"""All input for the create `CustomAvailability` mutation."""
input CreateCustomAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CustomAvailability` to be created by this mutation."""
  customAvailability: CustomAvailabilityInput!
}

"""An input for mutations affecting `CustomAvailability`"""
input CustomAvailabilityInput {
  id: String!
  userId: String!
  startTime: Datetime!
  endTime: Datetime!
  available: Boolean
  reason: String
}

"""The output of our create `Event` mutation."""
type CreateEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was created by this mutation."""
  event: Event

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Event`."""
  user: User

  """Reads a single `Team` that is related to this `Event`."""
  team: Team

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the create `Event` mutation."""
input CreateEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Event` to be created by this mutation."""
  event: EventInput!
}

"""An input for mutations affecting `Event`"""
input EventInput {
  id: String!
  title: String!
  description: String
  duration: Int!
  location: String
  date: Datetime!
  userId: String
  teamId: String
}

"""The output of our create `Team` mutation."""
type CreateTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was created by this mutation."""
  team: Team

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Team`. May be used by Relay 1."""
  teamEdge(
    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamsEdge
}

"""All input for the create `Team` mutation."""
input CreateTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Team` to be created by this mutation."""
  team: TeamInput!
}

"""An input for mutations affecting `Team`"""
input TeamInput {
  id: String!
  name: String!
  createdAt: Datetime
  updatedAt: Datetime!
}

"""The output of our create `TeamMembership` mutation."""
type CreateTeamMembershipPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamMembership` that was created by this mutation."""
  teamMembership: TeamMembership

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TeamMembership`."""
  user: User

  """Reads a single `Team` that is related to this `TeamMembership`."""
  team: Team

  """An edge for our `TeamMembership`. May be used by Relay 1."""
  teamMembershipEdge(
    """The method to use when ordering `TeamMembership`."""
    orderBy: [TeamMembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamMembershipsEdge
}

"""All input for the create `TeamMembership` mutation."""
input CreateTeamMembershipInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TeamMembership` to be created by this mutation."""
  teamMembership: TeamMembershipInput!
}

"""An input for mutations affecting `TeamMembership`"""
input TeamMembershipInput {
  id: String!
  userId: String!
  teamId: String!
  role: TeamRole
  createdAt: Datetime
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  oidcId: String!
  firstName: String
  lastName: String
  gender: UserGender
  birthDay: Datetime
  email: String
  tel: String
  picture: String
}

"""The output of our create `UserDevice` mutation."""
type CreateUserDevicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDevice` that was created by this mutation."""
  userDevice: UserDevice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User

  """An edge for our `UserDevice`. May be used by Relay 1."""
  userDeviceEdge(
    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserDevicesEdge
}

"""All input for the create `UserDevice` mutation."""
input CreateUserDeviceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserDevice` to be created by this mutation."""
  userDevice: UserDeviceInput!
}

"""An input for mutations affecting `UserDevice`"""
input UserDeviceInput {
  userId: String!
  token: String!
  ua: JSON
}

"""The output of our update `Availability` mutation."""
type UpdateAvailabilityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Availability` that was updated by this mutation."""
  availability: Availability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Availability`."""
  user: User

  """An edge for our `Availability`. May be used by Relay 1."""
  availabilityEdge(
    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesEdge
}

"""All input for the `updateAvailabilityByNodeId` mutation."""
input UpdateAvailabilityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Availability` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Availability` being updated.
  """
  patch: AvailabilityPatch!
}

"""
Represents an update to a `Availability`. Fields that are set will be updated.
"""
input AvailabilityPatch {
  id: String
  userId: String
  dayOfWeek: Int
  startTime: Datetime
  endTime: Datetime
}

"""All input for the `updateAvailability` mutation."""
input UpdateAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Availability` being updated.
  """
  patch: AvailabilityPatch!
  id: String!
}

"""The output of our update `Booking` mutation."""
type UpdateBookingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Booking` that was updated by this mutation."""
  booking: Booking

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Booking`."""
  event: Event

  """Reads a single `User` that is related to this `Booking`."""
  user: User

  """An edge for our `Booking`. May be used by Relay 1."""
  bookingEdge(
    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsEdge
}

"""All input for the `updateBookingByNodeId` mutation."""
input UpdateBookingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Booking` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Booking` being updated.
  """
  patch: BookingPatch!
}

"""
Represents an update to a `Booking`. Fields that are set will be updated.
"""
input BookingPatch {
  eventId: String
  userId: String
  status: BookingStatus
}

"""All input for the `updateBooking` mutation."""
input UpdateBookingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Booking` being updated.
  """
  patch: BookingPatch!
  eventId: String!
  userId: String!
}

"""The output of our update `CustomAvailability` mutation."""
type UpdateCustomAvailabilityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CustomAvailability` that was updated by this mutation."""
  customAvailability: CustomAvailability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `CustomAvailability`."""
  user: User

  """An edge for our `CustomAvailability`. May be used by Relay 1."""
  customAvailabilityEdge(
    """The method to use when ordering `CustomAvailability`."""
    orderBy: [CustomAvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomAvailabilitiesEdge
}

"""All input for the `updateCustomAvailabilityByNodeId` mutation."""
input UpdateCustomAvailabilityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CustomAvailability` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CustomAvailability` being updated.
  """
  patch: CustomAvailabilityPatch!
}

"""
Represents an update to a `CustomAvailability`. Fields that are set will be updated.
"""
input CustomAvailabilityPatch {
  id: String
  userId: String
  startTime: Datetime
  endTime: Datetime
  available: Boolean
  reason: String
}

"""All input for the `updateCustomAvailability` mutation."""
input UpdateCustomAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CustomAvailability` being updated.
  """
  patch: CustomAvailabilityPatch!
  id: String!
}

"""The output of our update `Event` mutation."""
type UpdateEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was updated by this mutation."""
  event: Event

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Event`."""
  user: User

  """Reads a single `Team` that is related to this `Event`."""
  team: Team

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the `updateEventByNodeId` mutation."""
input UpdateEventByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Event` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Event` being updated.
  """
  patch: EventPatch!
}

"""
Represents an update to a `Event`. Fields that are set will be updated.
"""
input EventPatch {
  id: String
  title: String
  description: String
  duration: Int
  location: String
  date: Datetime
  userId: String
  teamId: String
}

"""All input for the `updateEvent` mutation."""
input UpdateEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Event` being updated.
  """
  patch: EventPatch!
  id: String!
}

"""The output of our update `Team` mutation."""
type UpdateTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was updated by this mutation."""
  team: Team

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Team`. May be used by Relay 1."""
  teamEdge(
    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamsEdge
}

"""All input for the `updateTeamByNodeId` mutation."""
input UpdateTeamByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Team` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Team` being updated.
  """
  patch: TeamPatch!
}

"""Represents an update to a `Team`. Fields that are set will be updated."""
input TeamPatch {
  id: String
  name: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateTeam` mutation."""
input UpdateTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Team` being updated.
  """
  patch: TeamPatch!
  id: String!
}

"""The output of our update `TeamMembership` mutation."""
type UpdateTeamMembershipPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamMembership` that was updated by this mutation."""
  teamMembership: TeamMembership

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TeamMembership`."""
  user: User

  """Reads a single `Team` that is related to this `TeamMembership`."""
  team: Team

  """An edge for our `TeamMembership`. May be used by Relay 1."""
  teamMembershipEdge(
    """The method to use when ordering `TeamMembership`."""
    orderBy: [TeamMembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamMembershipsEdge
}

"""All input for the `updateTeamMembershipByNodeId` mutation."""
input UpdateTeamMembershipByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamMembership` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TeamMembership` being updated.
  """
  patch: TeamMembershipPatch!
}

"""
Represents an update to a `TeamMembership`. Fields that are set will be updated.
"""
input TeamMembershipPatch {
  id: String
  userId: String
  teamId: String
  role: TeamRole
  createdAt: Datetime
}

"""All input for the `updateTeamMembership` mutation."""
input UpdateTeamMembershipInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TeamMembership` being updated.
  """
  patch: TeamMembershipPatch!
  id: String!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUserByNodeId` mutation."""
input UpdateUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  oidcId: String
  firstName: String
  lastName: String
  gender: UserGender
  birthDay: Datetime
  email: String
  tel: String
  picture: String
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
  oidcId: String!
}

"""The output of our update `UserDevice` mutation."""
type UpdateUserDevicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDevice` that was updated by this mutation."""
  userDevice: UserDevice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User

  """An edge for our `UserDevice`. May be used by Relay 1."""
  userDeviceEdge(
    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserDevicesEdge
}

"""All input for the `updateUserDeviceByNodeId` mutation."""
input UpdateUserDeviceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserDevice` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserDevice` being updated.
  """
  patch: UserDevicePatch!
}

"""
Represents an update to a `UserDevice`. Fields that are set will be updated.
"""
input UserDevicePatch {
  userId: String
  token: String
  ua: JSON
}

"""All input for the `updateUserDevice` mutation."""
input UpdateUserDeviceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserDevice` being updated.
  """
  patch: UserDevicePatch!
  userId: String!
  token: String!
}

"""All input for the `updateUserDeviceByToken` mutation."""
input UpdateUserDeviceByTokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserDevice` being updated.
  """
  patch: UserDevicePatch!
  token: String!
}

"""The output of our delete `Availability` mutation."""
type DeleteAvailabilityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Availability` that was deleted by this mutation."""
  availability: Availability
  deletedAvailabilityNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Availability`."""
  user: User

  """An edge for our `Availability`. May be used by Relay 1."""
  availabilityEdge(
    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesEdge
}

"""All input for the `deleteAvailabilityByNodeId` mutation."""
input DeleteAvailabilityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Availability` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAvailability` mutation."""
input DeleteAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Booking` mutation."""
type DeleteBookingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Booking` that was deleted by this mutation."""
  booking: Booking
  deletedBookingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Booking`."""
  event: Event

  """Reads a single `User` that is related to this `Booking`."""
  user: User

  """An edge for our `Booking`. May be used by Relay 1."""
  bookingEdge(
    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsEdge
}

"""All input for the `deleteBookingByNodeId` mutation."""
input DeleteBookingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Booking` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBooking` mutation."""
input DeleteBookingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  eventId: String!
  userId: String!
}

"""The output of our delete `CustomAvailability` mutation."""
type DeleteCustomAvailabilityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CustomAvailability` that was deleted by this mutation."""
  customAvailability: CustomAvailability
  deletedCustomAvailabilityNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `CustomAvailability`."""
  user: User

  """An edge for our `CustomAvailability`. May be used by Relay 1."""
  customAvailabilityEdge(
    """The method to use when ordering `CustomAvailability`."""
    orderBy: [CustomAvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomAvailabilitiesEdge
}

"""All input for the `deleteCustomAvailabilityByNodeId` mutation."""
input DeleteCustomAvailabilityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CustomAvailability` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCustomAvailability` mutation."""
input DeleteCustomAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Event` mutation."""
type DeleteEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was deleted by this mutation."""
  event: Event
  deletedEventNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Event`."""
  user: User

  """Reads a single `Team` that is related to this `Event`."""
  team: Team

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the `deleteEventByNodeId` mutation."""
input DeleteEventByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Event` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteEvent` mutation."""
input DeleteEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Team` mutation."""
type DeleteTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was deleted by this mutation."""
  team: Team
  deletedTeamNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Team`. May be used by Relay 1."""
  teamEdge(
    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamsEdge
}

"""All input for the `deleteTeamByNodeId` mutation."""
input DeleteTeamByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Team` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeam` mutation."""
input DeleteTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `TeamMembership` mutation."""
type DeleteTeamMembershipPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamMembership` that was deleted by this mutation."""
  teamMembership: TeamMembership
  deletedTeamMembershipNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TeamMembership`."""
  user: User

  """Reads a single `Team` that is related to this `TeamMembership`."""
  team: Team

  """An edge for our `TeamMembership`. May be used by Relay 1."""
  teamMembershipEdge(
    """The method to use when ordering `TeamMembership`."""
    orderBy: [TeamMembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamMembershipsEdge
}

"""All input for the `deleteTeamMembershipByNodeId` mutation."""
input DeleteTeamMembershipByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamMembership` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeamMembership` mutation."""
input DeleteTeamMembershipInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUserByNodeId` mutation."""
input DeleteUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  oidcId: String!
}

"""The output of our delete `UserDevice` mutation."""
type DeleteUserDevicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDevice` that was deleted by this mutation."""
  userDevice: UserDevice
  deletedUserDeviceNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User

  """An edge for our `UserDevice`. May be used by Relay 1."""
  userDeviceEdge(
    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserDevicesEdge
}

"""All input for the `deleteUserDeviceByNodeId` mutation."""
input DeleteUserDeviceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserDevice` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserDevice` mutation."""
input DeleteUserDeviceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: String!
  token: String!
}

"""All input for the `deleteUserDeviceByToken` mutation."""
input DeleteUserDeviceByTokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  token: String!
}

"""The output of our upsert `Availability` mutation."""
type UpsertAvailabilityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Availability` that was upserted by this mutation."""
  availability: Availability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Availability`."""
  user: User

  """An edge for our `Availability`. May be used by Relay 1."""
  availabilityEdge(
    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesEdge
}

"""Where conditions for the upsert `Availability` mutation."""
input UpsertAvailabilityWhere {
  id: String
}

"""All input for the upsert `Availability` mutation."""
input UpsertAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Availability` to be upserted by this mutation."""
  availability: AvailabilityInput!
}

"""The output of our upsert `Booking` mutation."""
type UpsertBookingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Booking` that was upserted by this mutation."""
  booking: Booking

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Event` that is related to this `Booking`."""
  event: Event

  """Reads a single `User` that is related to this `Booking`."""
  user: User

  """An edge for our `Booking`. May be used by Relay 1."""
  bookingEdge(
    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsEdge
}

"""Where conditions for the upsert `Booking` mutation."""
input UpsertBookingWhere {
  eventId: String
  userId: String
}

"""All input for the upsert `Booking` mutation."""
input UpsertBookingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Booking` to be upserted by this mutation."""
  booking: BookingInput!
}

"""The output of our upsert `CustomAvailability` mutation."""
type UpsertCustomAvailabilityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CustomAvailability` that was upserted by this mutation."""
  customAvailability: CustomAvailability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `CustomAvailability`."""
  user: User

  """An edge for our `CustomAvailability`. May be used by Relay 1."""
  customAvailabilityEdge(
    """The method to use when ordering `CustomAvailability`."""
    orderBy: [CustomAvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomAvailabilitiesEdge
}

"""Where conditions for the upsert `CustomAvailability` mutation."""
input UpsertCustomAvailabilityWhere {
  id: String
}

"""All input for the upsert `CustomAvailability` mutation."""
input UpsertCustomAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CustomAvailability` to be upserted by this mutation."""
  customAvailability: CustomAvailabilityInput!
}

"""The output of our upsert `Event` mutation."""
type UpsertEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was upserted by this mutation."""
  event: Event

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Event`."""
  user: User

  """Reads a single `Team` that is related to this `Event`."""
  team: Team

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""Where conditions for the upsert `Event` mutation."""
input UpsertEventWhere {
  id: String
}

"""All input for the upsert `Event` mutation."""
input UpsertEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Event` to be upserted by this mutation."""
  event: EventInput!
}

"""The output of our upsert `Team` mutation."""
type UpsertTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was upserted by this mutation."""
  team: Team

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Team`. May be used by Relay 1."""
  teamEdge(
    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamsEdge
}

"""Where conditions for the upsert `Team` mutation."""
input UpsertTeamWhere {
  id: String
}

"""All input for the upsert `Team` mutation."""
input UpsertTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Team` to be upserted by this mutation."""
  team: TeamInput!
}

"""The output of our upsert `TeamMembership` mutation."""
type UpsertTeamMembershipPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamMembership` that was upserted by this mutation."""
  teamMembership: TeamMembership

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TeamMembership`."""
  user: User

  """Reads a single `Team` that is related to this `TeamMembership`."""
  team: Team

  """An edge for our `TeamMembership`. May be used by Relay 1."""
  teamMembershipEdge(
    """The method to use when ordering `TeamMembership`."""
    orderBy: [TeamMembershipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamMembershipsEdge
}

"""Where conditions for the upsert `TeamMembership` mutation."""
input UpsertTeamMembershipWhere {
  id: String
}

"""All input for the upsert `TeamMembership` mutation."""
input UpsertTeamMembershipInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TeamMembership` to be upserted by this mutation."""
  teamMembership: TeamMembershipInput!
}

"""The output of our upsert `User` mutation."""
type UpsertUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was upserted by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""Where conditions for the upsert `User` mutation."""
input UpsertUserWhere {
  oidcId: String
}

"""All input for the upsert `User` mutation."""
input UpsertUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be upserted by this mutation."""
  user: UserInput!
}

"""The output of our upsert `UserDevice` mutation."""
type UpsertUserDevicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDevice` that was upserted by this mutation."""
  userDevice: UserDevice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User

  """An edge for our `UserDevice`. May be used by Relay 1."""
  userDeviceEdge(
    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserDevicesEdge
}

"""Where conditions for the upsert `UserDevice` mutation."""
input UpsertUserDeviceWhere {
  userId: String
  token: String
}

"""All input for the upsert `UserDevice` mutation."""
input UpsertUserDeviceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserDevice` to be upserted by this mutation."""
  userDevice: UserDeviceInput!
}

"""
The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.

#### Live Queries

Live query fields are differentiated by containing `(live)` at the end of their
description, they are added for each field in the `Query` type. When you
subscribe to a live query field, the selection set will be evaluated and sent to
the client, and then most things\* that would cause the output of the selection
set to change will trigger the selection set to be re-evaluated and the results
to be re-sent to the client.

_(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_

Live queries can be very expensive, so try and keep them small and focussed.

#### Events

Event fields will run their selection set when, and only when, the specified
server-side event occurs. This makes them a lot more efficient than Live
Queries, but it is still recommended that you keep payloads fairly small.
"""
type Subscription {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form. (live)
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live)
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`. (live)"""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Availability`. (live)"""
  availabilities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailabilityFilter
  ): AvailabilitiesConnection

  """Reads and enables pagination through a set of `Booking`. (live)"""
  bookings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter
  ): BookingsConnection

  """
  Reads and enables pagination through a set of `CustomAvailability`. (live)
  """
  customAvailabilities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CustomAvailability`."""
    orderBy: [CustomAvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomAvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CustomAvailabilityFilter
  ): CustomAvailabilitiesConnection

  """Reads and enables pagination through a set of `Event`. (live)"""
  events(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EventCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EventFilter
  ): EventsConnection

  """Reads and enables pagination through a set of `Team`. (live)"""
  teams(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TeamFilter
  ): TeamsConnection

  """Reads and enables pagination through a set of `TeamMembership`. (live)"""
  teamMemberships(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamMembership`."""
    orderBy: [TeamMembershipsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamMembershipCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TeamMembershipFilter
  ): TeamMembershipsConnection

  """Reads and enables pagination through a set of `User`. (live)"""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection

  """Reads and enables pagination through a set of `UserDevice`. (live)"""
  userDevices(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDeviceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDeviceFilter
  ): UserDevicesConnection

  """ (live)"""
  availability(id: String!): Availability

  """ (live)"""
  booking(eventId: String!, userId: String!): Booking

  """ (live)"""
  customAvailability(id: String!): CustomAvailability

  """ (live)"""
  event(id: String!): Event

  """ (live)"""
  team(id: String!): Team

  """ (live)"""
  teamMembership(id: String!): TeamMembership

  """ (live)"""
  user(oidcId: String!): User

  """ (live)"""
  userDevice(userId: String!, token: String!): UserDevice

  """ (live)"""
  userDeviceByToken(token: String!): UserDevice

  """Reads a single `Availability` using its globally unique `ID`. (live)"""
  availabilityByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Availability`.
    """
    nodeId: ID!
  ): Availability

  """Reads a single `Booking` using its globally unique `ID`. (live)"""
  bookingByNodeId(
    """The globally unique `ID` to be used in selecting a single `Booking`."""
    nodeId: ID!
  ): Booking

  """
  Reads a single `CustomAvailability` using its globally unique `ID`. (live)
  """
  customAvailabilityByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CustomAvailability`.
    """
    nodeId: ID!
  ): CustomAvailability

  """Reads a single `Event` using its globally unique `ID`. (live)"""
  eventByNodeId(
    """The globally unique `ID` to be used in selecting a single `Event`."""
    nodeId: ID!
  ): Event

  """Reads a single `Team` using its globally unique `ID`. (live)"""
  teamByNodeId(
    """The globally unique `ID` to be used in selecting a single `Team`."""
    nodeId: ID!
  ): Team

  """Reads a single `TeamMembership` using its globally unique `ID`. (live)"""
  teamMembershipByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TeamMembership`.
    """
    nodeId: ID!
  ): TeamMembership

  """Reads a single `User` using its globally unique `ID`. (live)"""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User

  """Reads a single `UserDevice` using its globally unique `ID`. (live)"""
  userDeviceByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserDevice`.
    """
    nodeId: ID!
  ): UserDevice
}
